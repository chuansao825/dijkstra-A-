#pragma once
#ifndef _SHORTESTPATH_H
#define _SHORTESTPATH_H

#include "PQ.h"
#include <stack>
#include <time.h>
#include"PQ2.h"


/*****************************************************************************
* @author  : bigbiginsulator/chuansao825                                                             *
* @date    :2021/11/29
* @file    :
* @brief   :使用dijkstra算法求解最短路径，并使用优先队列进行优化
*****************************************************************************/
class shortestpath {
public:
	graph* g;	//一个图
	int s;		//求最短路径的起始顶点
	double* disTo;	//从顶点s到下标index的当前已知最短距离
	edge** edgeTo;		//最短路径上index顶点与父顶点之间的边
	PQ* pq;		//基于小根堆的优先队列
	PQ2* pq2;	//基于多叉堆的优先队列
	clock_t start;
	clock_t end;
	double getTime() { return (double)(end - start); }

	/*****************************************************************************
	* @name   :
	* @input   :g:指向一个图的指针 , s:求最短路径的起始顶点
	* @output  :
	* @brief   :将起始点外的disTo中的元素置为INF，创建edge数组
	*****************************************************************************/
	shortestpath(graph* g, int s);


	/*****************************************************************************
	* @name   :
	* @input   :void
	* @output  :void
	* @brief   :使用dijkstra算法求解起始点到其余所有点的最短路径，结果储存在disTo与edgeTo数组中
	*****************************************************************************/
	void solveShortestPath();



	/*****************************************************************************
	* @name   :
	* @input   :目的点的序号
	* @output  :void
	* @brief   :优化后的方法1，只要找到到目的点的最短路径就结束
	*****************************************************************************/
	void solveShortestPath(int destination);




	/*****************************************************************************
	* @name   :
	* @input   :destination:目标结点的序号
	* @output  :
	* @brief   :使用A*算法，启发函数使用欧氏几何距离
	*			f(n)=g(n)+h(n)，数值越小优先级越高
	*			g(n)为节点n到起始点s的最短路径,通过松弛操作获得
	*			h(n)为节点n到目标点的预估代价，使用启发函数求得
	*			维护两个集合：open_set和clost_set
	*			容器使用基于三叉堆的优先队列
	*****************************************************************************/
	void AStar (int destination);




	/*****************************************************************************
	* @name   :
	* @input   :
	* @output  :
	* @brief   :使用了基于三叉堆的优先队列的dijkstra
	*****************************************************************************/
	void solveShortestPath2(int destination);



	/*****************************************************************************
	* @name   :
	* @input   :int
	* @output  :
	* @brief   :根据disTo与edgeTo数组信息打印起始点到destination的最短路径
	*****************************************************************************/
	void printShortestPath(int destination);



	/*****************************************************************************
	* @name   :
	* @input   :
	* @output  :
	* @brief   :析构函数
	*****************************************************************************/
	~shortestpath();
};

#endif